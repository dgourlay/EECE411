#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
# -----------------------------------------------------------------
# $Id: PLServiceCntl,v 1.3 2004/03/09 22:16:51 mbowman Exp $
#
# Copyright (c) 2004 Intel Corporation
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:

#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.

#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.

#     * Neither the name of the Intel Corporation nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# EXPORT LAWS: THIS LICENSE ADDS NO RESTRICTIONS TO THE EXPORT LAWS OF
# YOUR JURISDICTION. It is licensee's responsibility to comply with any
# export regulations applicable in licensee's jurisdiction. Under
# CURRENT (May 2000) U.S. export regulations this software is eligible
# for export from the U.S. and can be downloaded by or otherwise
# exported or reexported worldwide EXCEPT to U.S. embargoed destinations
# which include Cuba, Iraq, Libya, North Korea, Iran, Syria, Sudan,
# Afghanistan and any other country to which the U.S. has embargoed
# goods and services.

# -----------------------------------------------------------------
# PLServiceCntl
# Script that is run on the remote node to control the whole
# service.
# This file has generic constructs to control the cogs installed
# on this node.  Generally, though, much service customization will
# be done on this file.
# -----------------------------------------------------------------
use 5.008;
use strict;
use warnings;

use Config;

BEGIN {
    my $home = $ENV{'HOME'};
    my $arch = $Config{archname};
    push(@INC,"$home/PL/lib/perl5");
    push(@INC,"$home/PL/lib/perl5/$arch/auto");
}

# -----------------------------------------------------------------
# Load app specific libraries
# -----------------------------------------------------------------
use PlanetLab::PLDeploy;
use Getopt::Long;

my $gSvcCntl = PlanetLab::PLDeploy->new;

# -----------------------------------------------------------------
# Initialize Service information 
# -----------------------------------------------------------------
sub ReadLocalCogs {
    return glob($gSvcCntl->SliceRoot . "/Cogs/*");
}

# -----------------------------------------------------------------
# Loop through all the nodes and perform the passed cntl operation.
# Invocation: &EachCogCntl("COMMAND");
# -----------------------------------------------------------------
sub EachCogCntl {
    my ($func,$cogs_r,$params_r) = @_;
    my @cogs = @$cogs_r;

    # Pass the parameters on to the cog controller
    my $options = "";
    foreach my $key (keys %$params_r) {
	my $val = $params_r->{$key};
	$options .= " --set $key=$val";
    }

    # Now invoke the function on each of the cogs
    foreach my $cog (@cogs) {
	my $cmd = $gSvcCntl->SliceRoot . "/Cogs/$cog/PLCogCntl $func $options";
        $gSvcCntl->DoSystem($cmd);
    }
}

# -----------------------------------------------------------------
# CREATE
# Called before cogs are deployed to a node
# -----------------------------------------------------------------
sub CREATE {
    my ($cogs_r,$params_r) = @_;

    # Create the local OUTBOUND directories for each of the cogs
    my @cogs = @$cogs_r;
    foreach my $cog (@cogs) {
	my $cdir = $gSvcCntl->SliceRoot . "/Cogs/$cog/OUTBOUND";
	$gSvcCntl->DoSystem("mkdir -p $cdir") unless -d $cdir;
    }

    # Call out to a local script to initialize the environment
    if (-x $gSvcCntl->SliceInit) {
	$gSvcCntl->DoSystem($gSvcCntl->SliceInit);
    }
}

# -----------------------------------------------------------------
# DEPLOY
# Called after the service has been initially installed on the node.
# -----------------------------------------------------------------
sub DEPLOY {
    my ($cogs_r,$params_r) = @_;

    # Now invoke the DEPLOY command on each
    &EachCogCntl("DEPLOY",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
# START
# Start this service running
# -----------------------------------------------------------------
sub START {
    my ($cogs_r,$params_r) = @_;

    # Your service code here
    &EachCogCntl("START",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
# STOP
# Stop the running of this service
# -----------------------------------------------------------------
sub STOP {
    my ($cogs_r,$params_r) = @_;

    # Your service code here
    &EachCogCntl("STOP",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
# STATUS
# Return a short text status of the service message.
# -----------------------------------------------------------------
sub STATUS {
    my ($cogs_r,$params_r) = @_;

    # Your service code here
    &EachCogCntl("STATUS",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
# VERSION
# Return the version stamp for each Cog
# -----------------------------------------------------------------
sub VERSION {
    my ($cogs_r,$params_r) = @_;

    # Your service code here
    &EachCogCntl("VERSION",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
# CLEAN
# Called to clean up the various cogs on the machine. Invoke the clean
# operation on each one (cogs should remove themselves).
# -----------------------------------------------------------------
sub CLEAN {
    my ($cogs_r,$params_r) = @_;

    &EachCogCntl("CLEAN",$cogs_r,$params_r);

    # Clean the sliver directory as well if requested
    if (defined $params_r->{"all"} && $params_r->{"all"} == 1) {
	# This is VERY dangerous
	$gSvcCntl->DoSystem("/bin/rm -rf " . $gSvcCntl->SliceRoot);
    }
}

# -----------------------------------------------------------------
# PREPULL
# Called before the development machine pulls the information in
# the OUTBOUND directory.  This gives the node a chance to cleanup or
# format the data.
# -----------------------------------------------------------------
sub PREPULL {
    my ($cogs_r,$params_r) = @_;

    # Your service code here
    &EachCogCntl("PREPULL",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
# POSTPULL
# Called after the development machine has pulled the information from
# the OUTBOUND directory.  This give the node a chance to cleanup
# or reset the information.
# -----------------------------------------------------------------
sub POSTPULL {
    my ($cogs_r,$params_r) = @_;

    # Your service code here
    &EachCogCntl("POSTPULL",$cogs_r,$params_r);
}

# -----------------------------------------------------------------
sub Main {
    my $paramCmd = ($#ARGV >= 0) ? shift @ARGV : "HELP";
    
    # Process the parameters
    my @cogs = ();		# Cogs requested in the parameter list
    my %params = ();
    if (! GetOptions('cogs=s' => \@cogs, 'set=s' => \%params)) {
	print STDERR "PLServiceCntl $paramCmd [--cog <cog>]\n";
        exit;
    }

    # Set the verbose parameter
    $gSvcCntl->Verbose($params{"verbose"}) if (defined $params{"verbose"});

    # Initial trace information
    print " (PLServiceCntl) $paramCmd\n"
	if $gSvcCntl->Verbose;

    # Get the local list of cogs
    @cogs = &ReadLocalCogs if $#cogs < 0;


    &CREATE(\@cogs,\%params), exit       if ($paramCmd =~ m/^create$/i);
    &DEPLOY(\@cogs,\%params), exit       if ($paramCmd =~ m/^deploy$/i);
    &START(\@cogs,\%params), exit        if ($paramCmd =~ m/^start$/i);
    &STOP(\@cogs,\%params), exit         if ($paramCmd =~ m/^stop$/i);
    &STATUS(\@cogs,\%params), exit       if ($paramCmd =~ m/^status$/i);
    &VERSION(\@cogs,\%params), exit      if ($paramCmd =~ m/^version$/i);
    &CLEAN(\@cogs,\%params), exit        if ($paramCmd =~ m/^clean$/i);
    &PREPULL(\@cogs,\%params), exit      if ($paramCmd =~ m/^prepull$/i);
    &POSTPULL(\@cogs,\%params), exit     if ($paramCmd =~ m/^postpull$/i);

    die "Unknown command; $paramCmd\n";
}

&Main;
